//SINGLY LINKEDLIST
//In delete by PRN, typing starting prn fucks up.
//In dipslay, seperate display for pres and sec isnt happening.
//Node swap isnt happening
//Sorting is done . not merging

#include<iostream>
using namespace std;
class node
{
public:
	int prn;
	string name;
	node* next;
};
class ll
{
public:
	node* head;
	node* tail;
	ll()
	{
		head = NULL;
		tail = NULL;
	}
	void add_first(node* nnf);
	void add_between(node* nnb);
	void add_end(node* nnl);
	void details(node* just);
	void display(node* begin);
	void delete_first();
	void delete_between(int key);
	void delete_end();
	void disp_rev(node* temp);
	void concate_list(node* link);
	void sort();
};
void ll::details(node* just)
{
	cout << "Name :";
	cin >> just->name;
	cout << "PRN:";
	cin >> just->prn;
	just->next = NULL;
}
void ll::add_first(node* nnf)
{
	if (head == NULL)
	{
		head = nnf;
		tail = nnf;
	}
	else
	{
		nnf->next = head;
		head = nnf;
	}
}
void ll::add_between(node* nnb)
{
	int after;
	cout << "Enter the PRN after which you want to insert" << endl;
	cin >> after;
	node* temp;
	node* temp1;
	if (head == NULL)
	{
		head = nnb;
		tail = nnb;
	}
	else
	{
		temp = head;
		while (temp->prn != after)
		{
			temp = temp->next;
		}
		temp1 = temp->next;
		if (temp1 == NULL)
		{
			temp->next = nnb;
			tail = nnb;
		}
		else
		{
			temp->next = nnb;
			nnb->next = temp1;
		}
	}
}
void ll::add_end(node* nnl)
{
	if (head == NULL)
	{
		head = nnl;
		tail = nnl;
	}
	else
	{
		node* tmp;
		tmp = head;
		while (tmp->next != NULL)
		{
			tmp = tmp->next;
		}
		tmp->next = nnl;
		nnl->next = NULL;
	}
}
void ll::delete_first()
{
	node* tempo;
	if (head == NULL)
	{
		cout << "Nothing to delete" << endl;
	}
	else
	{
		tempo = head;
		head = head->next;
		delete(tempo);
	}
}
void ll::delete_between(int key)
{
	node* tem;
	node* follow;
	tem = head;
	follow = head;
	while (tem->prn != key)
	{
		follow = tem;
		tem = tem->next;
	}
	follow->next = tem->next;
	delete(tem);
}
void ll::delete_end()
{
	node* tmp;
	node* tmp1;
	if (tail == NULL)
	{
		cout << "Nothing to delete" << endl;
	}
	else
	{
		tmp = head;
		while (tmp->next->next != NULL)
		{
			tmp = tmp->next;
		}
		tmp1 = tmp->next;
		tmp->next = NULL;
		tail = tmp;
		delete(tmp1);
	}
}
void ll::disp_rev(node* temp)
{
	if (temp->next == NULL)
	{
		cout << temp->name << endl;
		cout << temp->prn << endl;
	}
	else
	{
		disp_rev(temp->next);

		cout << temp->name << endl;
		cout << temp->prn << endl;
	}

}
void ll::concate_list(node* link)
{
	node* temp = head;
	while (temp->next != NULL)
	{
		temp = temp->next;
	}
	temp->next = link;

}
void ll::sort()
{
	node* temp1;
	node* temp2;
	node* temp3;
	node* follow = head;
	int temp_prn;
	string temp_name;

	for (temp1 = head; temp1 != NULL; temp1 = temp1->next)
	{
		for (temp2 = head; temp2->next != NULL; temp2 = temp2->next)
		{
			//By Node swap
		   /* if (temp3->next != NULL)
			{
				if (temp2->prn > temp3->prn)
				{
					cout << "in" << endl;
					//swap here
					follow->next = temp3;
					temp2->next = temp3->next;
					temp3->next = temp2;
				   // display(head);
				}
				follow = temp2;
			}
			else
			{
				if (temp2->prn > temp3->prn)
				{
					follow->next = temp3;
					temp3->next = temp2;
					temp2->next = NULL;

				}
				follow = temp2;
			}
			*/

			//BY DATA SWAP 
			temp3 = temp2->next;
			if (temp2->prn > temp3->prn)
			{
				temp_prn = temp3->prn;
				temp3->prn = temp2->prn;
				temp2->prn = temp_prn;

				temp_name = temp3->name;
				temp3->name = temp2->name;
				temp2->name = temp_name;
			}
		}
		//temp1 = temp1->next;
	}

}
void ll::display(node* begin)
{
	int count = 0;
	while (begin != NULL)
	{
		cout << begin->name << endl;
		cout << begin->prn << endl;
		begin = begin->next;
		count++;
	}
	cout << "Total members " << count << endl;
}
int main()
{
	int key, key1;
	ll a;
	cout << "DIV A" << endl;
	cout << "PRESIDENT" << endl;
	node* nnf = new node;
	cout << "Enter president details" << endl;
	a.details(nnf);
	nnf->next = NULL;
	a.add_first(nnf);
	a.display(a.head);
	int x;
	cout << "MEMBERS" << endl;
	do
	{
		node* nnb = new node;
		a.details(nnb);
		nnb->next = NULL;
		a.add_between(nnb);
		a.display(a.head);
		cout << "Enter 0 to stop " << endl;
		cin >> x;
	} while (x != 0);


	node* nnl = new node;
	cout << "Enter secretary details" << endl;
	a.details(nnl);
	nnl->next = NULL;
	a.add_end(nnl);
	a.display(a.head);
	cout << "Delete at end" << endl;
	a.delete_end();
	a.display(a.head);
	cout << "Enter PRN of the person to be deleted" << endl;
	cin >> key;
	a.delete_between(key);
	a.display(a.head);
	cout << "Delete at begin" << endl;
	nnf = nnf->next;
	a.delete_first();
	a.display(a.head);


	cout << "DIV A REVERSE" << endl;
	a.disp_rev(a.head);
	cout << "Members of DIV A" << endl;
	a.display(a.head);

	ll b;
	cout << "DIV B" << endl;
	node* nnfB = new node;
	cout << "Enter president details" << endl;
	b.details(nnfB);
	nnfB->next = NULL;
	b.add_first(nnfB);
	b.display(b.head);
	int y;
	do
	{
		node* nnbB = new node;
		b.details(nnbB);
		nnbB->next = NULL;
		b.add_between(nnbB);
		b.display(b.head);
		cout << "Enter 0 to stop " << endl;
		cin >> y;
	} while (y != 0);

	node* nnlB = new node;
	cout << "Enter secretary details" << endl;
	b.details(nnlB);
	nnlB->next = NULL;
	b.add_end(nnlB);
	b.display(b.head);
	cout << "Delete at end" << endl;
	b.delete_end();
	b.display(b.head);
	cout << "Enter PRN of the person to be deleted" << endl;
	cin >> key1;
	b.delete_between(key1);
	b.display(b.head);
	cout << "Delete at begin" << endl;
	nnfB = nnfB->next;
	b.delete_first();
	b.display(b.head);
	cout << "DIV B REVERSE" << endl;
	b.disp_rev(b.head);
	cout << "Members of DIV B" << endl;
	b.display(b.head);

	a.concate_list(b.head);
	cout << "DISPLAY" << endl;
	a.display(a.head);

	cout << "SORT LIST" << endl;
	a.sort();
	a.display(a.head);

	return 0;
}
